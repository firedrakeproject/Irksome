<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Solving the Heat Equation with Bounds Constraints &#8212; Irksome 20202.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/fenics.css?v=c6f455f8" />
    <script src="../_static/documentation_options.js?v=41c113e4"></script>
    <script src="../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Solving the Heat Equation with Irksome" href="demo_heat_adapt.py.html" />
    <link rel="prev" title="Solving the telegraph equation with a stage-decoupled preconditioner" href="demo_wave_clines.py.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="../_static/featured.css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45089752-1', 'https://github.com/firedrakeproject/Irksome');
  ga('send', 'pageview');
</script>


<link rel="shortcut icon" href="../_static/icon.ico" />


  </head><body>
<div class="wrapper">
  
  <center><a href="../index.html"><img src="../_static/fence.svg" width="450px" alt="Irksome Project Banner" /></a></center>
  
  <div id="access">
    <div class="menu">
      <ul>
          <li class="page_item"><a href="https://github.com/firedrakeproject/Irksome" title="GitHub">GitHub</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
    <div class="demos/demo_bounded_heat.py">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="solving-the-heat-equation-with-bounds-constraints">
<h1>Solving the Heat Equation with Bounds Constraints<a class="headerlink" href="#solving-the-heat-equation-with-bounds-constraints" title="Link to this heading">Â¶</a></h1>
<p>In this demo we solve the simple heat equation with bounds constraints applied uniformly in time and space.
Consider the simple heat equation on <span class="math notranslate nohighlight">\(\Omega = [0,1]\times [0,1]\)</span>, with boundary <span class="math notranslate nohighlight">\(\Gamma\)</span>:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}u_t - \Delta u &amp;= f\\u &amp; = g \quad \textrm{on}\ \Gamma\end{aligned}\end{align} \]</div>
<p>for some known functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>. The solution will be some function <span class="math notranslate nohighlight">\(u\in V\)</span>, for
a suitable function space <span class="math notranslate nohighlight">\(V\)</span>.</p>
<p>The weak form is found by multiplying by an arbitrary test function <span class="math notranslate nohighlight">\(v\in V\)</span> and integrating over <span class="math notranslate nohighlight">\(\Omega\)</span>.
We then have the variational problem of finding <span class="math notranslate nohighlight">\(u:[0,T]\rightarrow V\)</span> such that
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">u_t</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span>\<span class="n">nabla</span> <span class="n">u</span><span class="p">,</span> \<span class="n">nabla</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>\<span class="n">quad</span> \<span class="n">forall</span> <span class="n">v</span> \<span class="ow">in</span> <span class="n">V</span> \<span class="n">textrm</span><span class="p">{</span> <span class="ow">and</span> <span class="p">}</span> <span class="n">t</span>\<span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">],</span>
</pre></div>
</div>
<p>subject to the boundary condition <span class="math notranslate nohighlight">\(u = g\)</span> on <span class="math notranslate nohighlight">\(\Gamma\)</span>.  This demo uses particular choices of the
functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> to be defined below.</p>
<p>The approach to bounds constraints below relies on the geometric properties of the Bernstein basis.
In one dimension (on <span class="math notranslate nohighlight">\([0,1]\)</span>), the graph of the polynomial
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> \<span class="n">sum_</span><span class="p">{</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}</span><span class="o">^</span><span class="n">n</span> <span class="n">p_i</span> <span class="n">b_i</span><span class="o">^</span><span class="n">n</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(b_i^n(x)\)</span> are Bernstein basis polynomials, lies in the convex-hull of the points
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">left</span>\<span class="p">{</span>\<span class="n">left</span><span class="p">(</span>\<span class="n">frac</span><span class="p">{</span><span class="n">i</span><span class="p">}{</span><span class="n">n</span><span class="p">},</span> <span class="n">p_i</span>\<span class="n">right</span><span class="p">)</span>\<span class="n">right</span>\<span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}</span><span class="o">^</span><span class="n">n</span><span class="o">.</span>
</pre></div>
</div>
<p>In particular, if the coefficients <span class="math notranslate nohighlight">\(p_i\)</span> lie in the interval <span class="math notranslate nohighlight">\([m,M]\)</span>, then the output of <span class="math notranslate nohighlight">\(p(x)\)</span> will
also fall within this range.  Similar results hold in higher dimensions.  This property provides a straightforward
approach to uniformly enforced bounds constraints in both space and time.</p>
<p>First, we must import firedrake and certain items from Irksome:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">firedrake</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">irksome</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dt</span><span class="p">,</span> <span class="n">MeshConstant</span><span class="p">,</span> <span class="n">RadauIIA</span><span class="p">,</span> <span class="n">TimeStepper</span><span class="p">,</span> <span class="n">BoundsConstrainedDirichletBC</span>
</pre></div>
</div>
<p>Finally, numpy provides us with the upper bound of infinity:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>We first define the mesh and the necessary function space. We choose
quadratic Bernstein polynomials to support bounds-constraints in space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">32</span>

<span class="n">msh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">msh</span><span class="p">,</span> <span class="s2">&quot;Bernstein&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to enforce bounds constraints in time, we must utilize a collocation method.
In this demo, we will time-step using the L-stable, fully implicit, 2-stage RadauIIA
Runge-Kutta method. The bounds will be passed as an argument to the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">advance</span></code> method. We now define the Butcher Tableau and variables to store the
time step, current time, and final time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">butcher_tableau</span> <span class="o">=</span> <span class="n">RadauIIA</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">MC</span> <span class="o">=</span> <span class="n">MeshConstant</span><span class="p">(</span><span class="n">msh</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">MC</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">MC</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">Tf</span> <span class="o">=</span> <span class="n">MC</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>We will find an approximate solution at time <span class="math notranslate nohighlight">\(t=1.0\)</span> with and without
enforcing a constraint on the lower bound. We will need the following pair of solver
parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lu_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;snes_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ksponly&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mat_type&quot;</span><span class="p">:</span> <span class="s2">&quot;aij&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;lu&quot;</span>
<span class="p">}</span>

<span class="n">vi_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;snes_type&quot;</span><span class="p">:</span> <span class="s2">&quot;vinewtonrsls&quot;</span><span class="p">,</span>
    <span class="s2">&quot;snes_max_it&quot;</span><span class="p">:</span> <span class="mi">300</span><span class="p">,</span>
    <span class="s2">&quot;snes_atol&quot;</span><span class="p">:</span> <span class="mf">1.e-8</span><span class="p">,</span>
    <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mat_type&quot;</span><span class="p">:</span> <span class="s2">&quot;aij&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;lu&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We now define the right-hand side using the method of manufactured solutions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">msh</span><span class="p">)</span>

<span class="n">uexact</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">tanh</span><span class="p">((</span><span class="mf">0.1</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mf">0.015</span><span class="p">)))</span>

<span class="n">rhs</span> <span class="o">=</span> <span class="n">Dt</span><span class="p">(</span><span class="n">uexact</span><span class="p">)</span> <span class="o">-</span> <span class="n">div</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">uexact</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the exact solution is uniformly positive in space and time. Using a manufactured
solution, one usually interpolates or projects the exact solution at time <span class="math notranslate nohighlight">\(t = 0\)</span> onto the
approximation space to obtain the initial condition. Interpolation does not work with the
Bernstein basis, and there is no guarantee that an interpolant or projection would satisfy the bounds constraints.
To guarantee that the initial condition satisfies the bounds constraints, we solve a variational
inequality:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_init</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">u_init</span> <span class="o">-</span> <span class="n">uexact</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>

<span class="n">nlvp</span> <span class="o">=</span> <span class="n">NonlinearVariationalProblem</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u_init</span><span class="p">)</span>
<span class="n">nlvs</span> <span class="o">=</span> <span class="n">NonlinearVariationalSolver</span><span class="p">(</span><span class="n">nlvp</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">vi_params</span><span class="p">)</span>

<span class="n">lb</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">ub</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="n">ub</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="n">lb</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">nlvs</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">))</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u_init</span><span class="p">)</span>

<span class="n">u_c</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_c</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u_init</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">u_c</span></code> now hold a bounds-constrained approximation to the exact solution
at <span class="math notranslate nohighlight">\(t = 0\)</span>.  Note that <cite>ub = None</cite> is also supported and gets internally converted
to what we have here.</p>
<p>We now construct semidiscrete variational problems for both the constrained and unconstrained
approximations using UFL notation and the <code class="docutils literal notranslate"><span class="pre">Dt</span></code> operator from Irksome:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">Dt</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span>

<span class="n">v_c</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="n">F_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">Dt</span><span class="p">(</span><span class="n">u_c</span><span class="p">),</span> <span class="n">v_c</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u_c</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v_c</span><span class="p">))</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">v_c</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p>We use exact boundary conditions in both cases. When <span class="math notranslate nohighlight">\(g\)</span> is the trace of a function
defined over the whole domain, Firedrake creates its own version of the boundary condition by either interpolating
or projecting that function onto the finite element space and computing the trace of the result.
To ensure the internal boundary condition satisfies the bounds constraints, we will pass the bounds to
the <code class="xref py py-class docutils literal notranslate"><span class="pre">TimeStepper</span></code> below.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">uexact</span><span class="p">,</span> <span class="s2">&quot;on_boundary&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For the unconstrained approximation, we configure the <code class="xref py py-class docutils literal notranslate"><span class="pre">TimeStepper</span></code> in a
familiar way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stepper</span> <span class="o">=</span> <span class="n">TimeStepper</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">butcher_tableau</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">lu_params</span><span class="p">)</span>
</pre></div>
</div>
<p>We will enforce nonnegativity when finding the constrained approximation. We now set up the keyword database to
configure an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">TimeStepper</span></code> for this task. We first specify, using the
keyword <code class="docutils literal notranslate"><span class="pre">stage_type</span></code>, that we wish to use a stage-value formulation of the underlying collocation
method. The keyword <code class="docutils literal notranslate"><span class="pre">basis_type</span></code> then allows us to change the basis of the collocation
polynomial to the Bernstein basis. Having done this, we must specify a solver which is able to handle bounds
constraints. In this example we solve a variational inequality using <code class="docutils literal notranslate"><span class="pre">vinewtonrsls</span></code> by passing <code class="docutils literal notranslate"><span class="pre">vi_params</span></code>
as <code class="docutils literal notranslate"><span class="pre">solver_parameters</span></code> to the <code class="xref py py-class docutils literal notranslate"><span class="pre">TimeStepper</span></code>.</p>
<p>We set the bounds as follows (reusing those defined in the initial condition):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;stage&#39;</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
</pre></div>
</div>
<p>Internally, Firedrake will project the boundary condition expression into the entire space and match degrees of freedom
on the boundary.  This could introduce bounds violations.  To ensure this does not happen, we can use a special kind
of boundary condition that projects with bounds contraints.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bc</span> <span class="o">=</span> <span class="n">BoundsConstrainedDirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">uexact</span><span class="p">,</span> <span class="s2">&quot;on_boundary&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">),</span> <span class="n">solver_parameters</span><span class="o">=</span><span class="n">vi_params</span><span class="p">)</span>

<span class="n">kwargs_c</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;bounds&quot;</span><span class="p">:</span> <span class="n">bounds</span><span class="p">,</span>
            <span class="s2">&quot;stage_type&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
            <span class="s2">&quot;basis_type&quot;</span><span class="p">:</span> <span class="s1">&#39;Bernstein&#39;</span><span class="p">,</span>
            <span class="s2">&quot;solver_parameters&quot;</span><span class="p">:</span> <span class="n">vi_params</span>
        <span class="p">}</span>

<span class="n">stepper_c</span> <span class="o">=</span> <span class="n">TimeStepper</span><span class="p">(</span><span class="n">F_c</span><span class="p">,</span> <span class="n">butcher_tableau</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">u_c</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_c</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that if one does not set the <code class="docutils literal notranslate"><span class="pre">basis_type</span></code> to Bernstein, the standard basis will be used. Solving for the
Bernstein coefficients of the collocation polynomial we obtain uniform-in-time bounds constraints. If the standard
basis is used, the bounds constraints are guaranteed at the Runge-Kutta stages and the discrete times, but not necessarily
between them.</p>
<p>When using a stage-value formulation, passing <code class="docutils literal notranslate"><span class="pre">bounds</span></code> to the <code class="xref py py-class docutils literal notranslate"><span class="pre">TimeStepper</span></code> through the <code class="xref py py-meth docutils literal notranslate"><span class="pre">advance</span></code> method
will enforce the bounds constraints at the discrete stages and time levels (this results in uniformly enforced constraints when using
the Bernstein basis).</p>
<p>We now advance both semidiscrete systems in the usual way. We add the bounds as an argument
to the <code class="xref py py-meth docutils literal notranslate"><span class="pre">advance</span></code> method for the constrained approximation.</p>
<p>In order to monitor our approximate solutions, we check the minimum value of each after every step in time.
If an approximate solution violates the lower bound, we append a tuple to indicate the time and minimum value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">violations_for_unconstrained_method</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">violations_for_constrained_method</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">timestep</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">Tf</span><span class="p">)):</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">Tf</span><span class="p">)):</span>
        <span class="n">dt</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">Tf</span><span class="p">)</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="n">stepper</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
    <span class="n">stepper_c</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>

    <span class="n">t</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">timestep</span> <span class="o">=</span> <span class="n">timestep</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">min_value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">violations_for_unconstrained_method</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">timestep</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>

    <span class="n">min_value_c</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">u_c</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_value_c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">violations_for_constrained_method</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">timestep</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">min_value_c</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>

    <span class="nb">print</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>Finally, we print the relative <span class="math notranslate nohighlight">\(L^2\)</span> error and the time and severity (if any) of constraint violations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">legacy</span><span class="o">=</span><span class="s1">&#39;1.25&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Relative L^2 norm of the unconstrained solution: </span><span class="si">{</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">uexact</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">norm</span><span class="p">(</span><span class="n">uexact</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Relative L^2 norm of the constrained solution:   </span><span class="si">{</span><span class="n">norm</span><span class="p">(</span><span class="n">u_c</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">uexact</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">norm</span><span class="p">(</span><span class="n">uexact</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;List of constraint violations in the form (time, time step, minimum value) for each approximation:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unconstrained solution: </span><span class="si">{</span><span class="n">violations_for_unconstrained_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Constrained solution: </span><span class="si">{</span><span class="n">violations_for_constrained_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2020-, Robert C Kirby and others.
    </div>
  </body>
</html>