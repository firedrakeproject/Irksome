<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Block diagonal preconditioners for the heat equation &#8212; Irksome 20202.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/fenics.css?v=c6f455f8" />
    <script src="../_static/documentation_options.js?v=41c113e4"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Solving the heat equation with monolithic multigrid" href="demo_heat_mg.py.html" />
    <link rel="prev" title="Solving the Navier-Stokes Equations with Irksome" href="demo_nse.py.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="../_static/featured.css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45089752-1', 'https://github.com/firedrakeproject/Irksome');
  ga('send', 'pageview');
</script>


<link rel="shortcut icon" href="../_static/icon.ico" />


  </head><body>
<div class="wrapper">
  
  <center><a href="../index.html"><img src="../_static/fence.svg" width="450px" alt="Irksome Project Banner" /></a></center>
  
  <div id="access">
    <div class="menu">
      <ul>
          <li class="page_item"><a href="https://github.com/firedrakeproject/Irksome" title="GitHub">GitHub</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
    <div class="demos/demo_heat_pc.py">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="block-diagonal-preconditioners-for-the-heat-equation">
<h1>Block diagonal preconditioners for the heat equation<a class="headerlink" href="#block-diagonal-preconditioners-for-the-heat-equation" title="Link to this heading">¶</a></h1>
<p>This demo applies the method suggested in:</p>
<p>Mardal, Nilssen, Staff, “Order-optimal preconditioners for implicit
Runge-Kutta schemes applied to parabolic PDEs”, SISC 29(1): 361–375 (2007),</p>
<p>to our ongoing heat equation demonstration problem on <span class="math notranslate nohighlight">\(\Omega = [0,10]
\times [0,10]\)</span>, with boundary <span class="math notranslate nohighlight">\(\Gamma\)</span>, giving rise to the weak form</p>
<div class="math notranslate nohighlight">
\[(u_t, v) + (\nabla u, \nabla v) = (f, v)\]</div>
<p>A multi-stage RK method applied to the heat equation gives a
block-structured system.  The on-diagonal blocks are quite similar to
what one obtains from a backward Euler discretization of the equation.</p>
<p>With a 2-stage method, we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[ \begin{array}{cc} A_{11} &amp; A_{12} \\ A_{21} &amp; A_{22} \end{array} \right]
\left[ \begin{array}{c} k_1 \\ k_2 \end{array} \right]
&amp;= \left[ \begin{array}{c} f_1 \\ f_2 \end{array} \right]\end{split}\]</div>
<p>And the suggestion (analyzed rigorously) of Mardal, Nilssen, and Staff
is to use a block diagonal preconditioner:</p>
<div class="math notranslate nohighlight">
\[\begin{split}P = \left[ \begin{array}{cc} A_{11} &amp; 0 \\ 0 &amp; A_{22} \end{array} \right]\end{split}\]</div>
<p>This allows one to leverage an existing methodology for a low order
method like backward Euler for the diagonal blocks.  In our case, we
will simply use an algebraic multigrid scheme, although one could
certainly use geometric multigrid or some other technique.</p>
<p>Common set-up for the problem:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">firedrake</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>  <span class="c1"># noqa: F403</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">irksome</span><span class="w"> </span><span class="kn">import</span> <span class="n">LobattoIIIC</span><span class="p">,</span> <span class="n">TimeStepper</span><span class="p">,</span> <span class="n">Dt</span><span class="p">,</span> <span class="n">MeshConstant</span>

<span class="n">butcher_tableau</span> <span class="o">=</span> <span class="n">LobattoIIIC</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">64</span>

<span class="n">x0</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">x1</span> <span class="o">=</span> <span class="mf">10.0</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">y1</span> <span class="o">=</span> <span class="mf">10.0</span>

<span class="n">msh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>

<span class="n">MC</span> <span class="o">=</span> <span class="n">MeshConstant</span><span class="p">(</span><span class="n">msh</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">MC</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">10.</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">MC</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">msh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">msh</span><span class="p">)</span>

<span class="n">S</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1000.0</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">Constant</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">Constant</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">Constant</span><span class="p">(</span><span class="n">y0</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">Constant</span><span class="p">(</span><span class="n">y1</span><span class="p">))</span><span class="o">/</span><span class="n">C</span>
<span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

<span class="n">uexact</span> <span class="o">=</span> <span class="n">B</span> <span class="o">*</span> <span class="n">atan</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">atan</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="n">t</span><span class="p">)))</span>
<span class="n">rhs</span> <span class="o">=</span> <span class="n">Dt</span><span class="p">(</span><span class="n">uexact</span><span class="p">)</span> <span class="o">-</span> <span class="n">div</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">uexact</span><span class="p">))</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">uexact</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">Dt</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;on_boundary&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we define the solver parameters.  PETSc-speak for taking the
block diagonal is an “additive fieldsplit”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mat_type&quot;</span><span class="p">:</span> <span class="s2">&quot;aij&quot;</span><span class="p">,</span>
          <span class="s2">&quot;snes_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ksponly&quot;</span><span class="p">,</span>
          <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;gmres&quot;</span><span class="p">,</span>
          <span class="s2">&quot;ksp_monitor&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
          <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;fieldsplit&quot;</span><span class="p">,</span>   <span class="c1"># block preconditioner</span>
          <span class="s2">&quot;pc_fieldsplit_type&quot;</span><span class="p">:</span> <span class="s2">&quot;additive&quot;</span>  <span class="c1"># block diagaonal</span>
          <span class="p">}</span>
</pre></div>
</div>
<p>We also have to configure the (approximate) inverse of for each
diagonal block.  We’ll just apply a sweek of gamg (PETSC’s algebraic
multigrid):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">per_field</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span>
             <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;gamg&quot;</span><span class="p">}</span>

<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">butcher_tableau</span><span class="o">.</span><span class="n">num_stages</span><span class="p">):</span>
    <span class="n">params</span><span class="p">[</span><span class="s2">&quot;fieldsplit_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">,)]</span> <span class="o">=</span> <span class="n">per_field</span>
</pre></div>
</div>
<p>Note that we have used the same technique for each RK stage, which is
probably typical.  However, it is not necessary at all.</p>
<p>To test this preconditioning strategy, we’ll create a time stepping
object which will set up the variational problem for us:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stepper</span> <span class="o">=</span> <span class="n">TimeStepper</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">butcher_tableau</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span>
                      <span class="n">solver_parameters</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<p>But, since we’re just testing the efficacy of the preconditioner,
we’ll solve the inside variational problem one time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stepper</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2020-, Robert C Kirby and others.
    </div>
  </body>
</html>