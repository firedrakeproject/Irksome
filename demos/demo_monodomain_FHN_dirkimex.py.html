<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Solving monodomain equations with Fitzhugh-Nagumo reaction and a DIRK-IMEX method &#8212; Irksome 20202.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/fenics.css?v=c6f455f8" />
    <script src="../_static/documentation_options.js?v=41c113e4"></script>
    <script src="../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Solving the Benjamin-Bona-Mahony equation" href="demo_bbm.py.html" />
    <link rel="prev" title="Solving monodomain equations with Fitzhugh-Nagumo reaction and an IMEX method" href="demo_monodomain_FHN.py.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="../_static/featured.css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45089752-1', 'https://github.com/firedrakeproject/Irksome');
  ga('send', 'pageview');
</script>


<link rel="shortcut icon" href="../_static/icon.ico" />


  </head><body>
<div class="wrapper">
  
  <center><a href="../index.html"><img src="../_static/fence.svg" width="450px" alt="Irksome Project Banner" /></a></center>
  
  <div id="access">
    <div class="menu">
      <ul>
          <li class="page_item"><a href="https://github.com/firedrakeproject/Irksome" title="GitHub">GitHub</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
    <div class="demos/demo_monodomain_FHN_dirkimex.py">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="solving-monodomain-equations-with-fitzhugh-nagumo-reaction-and-a-dirk-imex-method">
<h1>Solving monodomain equations with Fitzhugh-Nagumo reaction and a DIRK-IMEX method<a class="headerlink" href="#solving-monodomain-equations-with-fitzhugh-nagumo-reaction-and-a-dirk-imex-method" title="Link to this heading">¶</a></h1>
<p>We’re solving monodomain (reaction-diffusion) with a particular reaction term.
The basic form of the equation is:</p>
<div class="math notranslate nohighlight">
\[\chi \left( C_m u_t + I_{ion}(u) \right) = \nabla \cdot \sigma \nabla u\]</div>
<p>where <span class="math notranslate nohighlight">\(u\)</span> is the membrane potential, <span class="math notranslate nohighlight">\(\sigma\)</span> is the conductivity tensor, <span class="math notranslate nohighlight">\(C_m\)</span> is the specific capacitance of the cell membrane, and <span class="math notranslate nohighlight">\(\chi\)</span> is the surface area to volume ratio.  The term <span class="math notranslate nohighlight">\(I_{ion}\)</span> is current due to ionic flows through channels in the cell membranes, and may couple to a complicated reaction network.  In our case, we take the relatively simple model due to Fitzhugh and Nagumo.  Here, we have a separate concentration variable <span class="math notranslate nohighlight">\(c\)</span> satisfying the reaction equation:</p>
<div class="math notranslate nohighlight">
\[c_t = \epsilon( u + \beta - \gamma c)\]</div>
<p>for certain positive parameters <span class="math notranslate nohighlight">\(\beta\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span>, and the current takes the form of:</p>
<div class="math notranslate nohighlight">
\[I_{ion}(u, c) = \tfrac{1}{\epsilon} \left( u - \tfrac{u^3}{3} - c \right)\]</div>
<p>so that we have an overall system of two equations.  One of them is linear but stiff/diffusive, and the other is nonstiff but nonlinear.  This combination makes the system a good candidate for IMEX-type methods.</p>
<p>We start with standard Firedrake/Irksome imports:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">firedrake</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">And</span><span class="p">,</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">File</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">,</span>
                       <span class="n">RectangleMesh</span><span class="p">,</span> <span class="n">SpatialCoordinate</span><span class="p">,</span> <span class="n">TestFunctions</span><span class="p">,</span>
                       <span class="n">as_matrix</span><span class="p">,</span> <span class="n">conditional</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">inner</span><span class="p">,</span> <span class="n">split</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">irksome</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dt</span><span class="p">,</span> <span class="n">MeshConstant</span><span class="p">,</span> <span class="n">TimeStepper</span><span class="p">,</span> <span class="n">ARS_DIRK_IMEX</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">irksome.labeling</span><span class="w"> </span><span class="kn">import</span> <span class="n">explicit</span>
</pre></div>
</div>
<p>And we set up the mesh and function space.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="n">quadrilateral</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">polyOrder</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">V</span> <span class="o">*</span> <span class="n">V</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">MC</span> <span class="o">=</span> <span class="n">MeshConstant</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">MC</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">MC</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Specify the physical constants and initial conditions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">eps</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">beta</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="n">chi</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">capacitance</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

<span class="n">sigma1</span> <span class="o">=</span> <span class="n">sigma2</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="n">as_matrix</span><span class="p">([[</span><span class="n">sigma1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">]])</span>


<span class="n">initial_potential</span> <span class="o">=</span> <span class="n">conditional</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mf">3.5</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">2.0</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">1.28791</span><span class="p">))</span>
<span class="n">initial_cell</span> <span class="o">=</span> <span class="n">conditional</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="mi">31</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">39</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">35</span><span class="p">)),</span>
                          <span class="n">Constant</span><span class="p">(</span><span class="mf">2.0</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5758</span><span class="p">))</span>


<span class="n">uu</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
<span class="n">vu</span><span class="p">,</span> <span class="n">vc</span> <span class="o">=</span> <span class="n">TestFunctions</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
<span class="n">uu</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">initial_potential</span><span class="p">)</span>
<span class="n">uu</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">initial_cell</span><span class="p">)</span>

<span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">uu</span><span class="p">)</span>
</pre></div>
</div>
<p>This sets up the Butcher tableau.  Here, we use the DIRK-IMEX methods proposed
by Ascher, Ruuth, and Spiteri in their 1997 Applied Numerical Mathematics paper.
For this case, We use a four-stage method.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">butcher_tableau</span> <span class="o">=</span> <span class="n">ARS_DIRK_IMEX</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">ns</span> <span class="o">=</span> <span class="n">butcher_tableau</span><span class="o">.</span><span class="n">num_stages</span>
</pre></div>
</div>
<p>To access an IMEX method, we need to separately specify the implicit and explicit parts of the operator.
The part to be handled implicitly is taken to contain the time derivatives as well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F1</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">chi</span> <span class="o">*</span> <span class="n">capacitance</span> <span class="o">*</span> <span class="n">Dt</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">vu</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
      <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">grad</span><span class="p">(</span><span class="n">vu</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
      <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">Dt</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">vc</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">eps</span> <span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="n">vc</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
      <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">eps</span><span class="p">,</span> <span class="n">vc</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">vc</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p>This is the part to be handled explicitly.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F2</span> <span class="o">=</span> <span class="n">inner</span><span class="p">((</span><span class="n">chi</span><span class="o">/</span><span class="n">eps</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">vu</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>If we wanted to use a fully implicit method, we would just take F = F1 + F2.
Instead, we use a label:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F</span> <span class="o">=</span> <span class="n">F1</span> <span class="o">+</span> <span class="n">explicit</span><span class="p">(</span><span class="n">F2</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, set up solver parameters.  Since we’re using a DIRK-IMEX scheme, we can
specify only parameters for each stage.  We use an additive Schwarz (fieldsplit) method that applies AMG to the potential block and incomplete Cholesky to the cell block independently for each stage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;snes_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ksponly&quot;</span><span class="p">,</span>
          <span class="s2">&quot;ksp_monitor&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
          <span class="s2">&quot;mat_type&quot;</span><span class="p">:</span> <span class="s2">&quot;aij&quot;</span><span class="p">,</span>
          <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;fgmres&quot;</span><span class="p">,</span>
          <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;fieldsplit&quot;</span><span class="p">,</span>
          <span class="s2">&quot;pc_fieldsplit_type&quot;</span><span class="p">:</span> <span class="s2">&quot;additive&quot;</span><span class="p">,</span>
          <span class="s2">&quot;fieldsplit_0&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span>
              <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;gamg&quot;</span><span class="p">,</span>
          <span class="p">},</span>
          <span class="s2">&quot;fieldsplit_1&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span>
              <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;icc&quot;</span><span class="p">,</span>
          <span class="p">}}</span>
</pre></div>
</div>
<p>The DIRK-IMEX schemes also require a mass-matrix solver.  Here, we just use an incomplete Cholesky preconditioner for CG on the coupled system, which works fine.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mass_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;snes_type&quot;</span><span class="p">:</span> <span class="s2">&quot;ksponly&quot;</span><span class="p">,</span>
               <span class="s2">&quot;ksp_rtol&quot;</span><span class="p">:</span> <span class="mf">1.e-8</span><span class="p">,</span>
               <span class="s2">&quot;ksp_monitor&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
               <span class="s2">&quot;mat_type&quot;</span><span class="p">:</span> <span class="s2">&quot;aij&quot;</span><span class="p">,</span>
               <span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;cg&quot;</span><span class="p">,</span>
               <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;icc&quot;</span><span class="p">,</span>
              <span class="p">}</span>
</pre></div>
</div>
<p>Now, we access the IMEX method via the <cite>TimeStepper</cite> as with other methods.  Note that we specify somewhat different kwargs, needing to specify the implicit and explicit parts separately as well as separate solver options for the implicit and mass solvers.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stepper</span> <span class="o">=</span> <span class="n">TimeStepper</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">butcher_tableau</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">uu</span><span class="p">,</span>
                      <span class="n">stage_type</span><span class="o">=</span><span class="s2">&quot;dirkimex&quot;</span><span class="p">,</span>
                      <span class="n">solver_parameters</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                      <span class="n">mass_parameters</span><span class="o">=</span><span class="n">mass_params</span><span class="p">,</span>
                      <span class="n">Fexp</span><span class="o">=</span><span class="n">F2</span><span class="p">)</span>

<span class="n">uFinal</span><span class="p">,</span> <span class="n">cFinal</span> <span class="o">=</span> <span class="n">uu</span><span class="o">.</span><span class="n">subfunctions</span>
<span class="n">outfile1</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;FHN_results/FHN_2d_u.pvd&quot;</span><span class="p">)</span>
<span class="n">outfile2</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;FHN_results/FHN_2d_c.pvd&quot;</span><span class="p">)</span>
<span class="n">outfile1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">uFinal</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">outfile2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">cFinal</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stepper</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">outfile1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">uFinal</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">j</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span>
        <span class="n">outfile2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">cFinal</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">j</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span>
</pre></div>
</div>
<p>We can print out some solver statistics here.  We expect one implicit solve per stage per timestep, and that’s what we see with the four-stage method.  For this Butcher Tableau, we can avoid computing the final explicit stage (since it’s coefficient in the next stage reconstruction is zero), so we see the same number of mass solves.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nsteps</span><span class="p">,</span> <span class="n">n_nonlin</span><span class="p">,</span> <span class="n">n_lin</span><span class="p">,</span> <span class="n">n_nonlin_mass</span><span class="p">,</span> <span class="n">n_lin_mass</span> <span class="o">=</span> <span class="n">stepper</span><span class="o">.</span><span class="n">solver_stats</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time steps taken: </span><span class="si">{</span><span class="n">nsteps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">n_nonlin</span><span class="si">}</span><span class="s2"> nonlinear steps in implicit stage solves (should be </span><span class="si">{</span><span class="n">nsteps</span><span class="o">*</span><span class="n">ns</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">n_lin</span><span class="si">}</span><span class="s2"> linear steps in implicit stage solves&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">n_nonlin_mass</span><span class="si">}</span><span class="s2"> nonlinear steps in mass solves (should be </span><span class="si">{</span><span class="n">nsteps</span><span class="o">*</span><span class="n">ns</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">n_lin_mass</span><span class="si">}</span><span class="s2"> linear steps in mass solves&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2020-, Robert C Kirby and others.
    </div>
  </body>
</html>